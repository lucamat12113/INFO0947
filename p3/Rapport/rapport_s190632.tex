\documentclass[a4paper, 11pt, oneside]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{array}
\usepackage{shortvrb}
\usepackage{listings}
\usepackage[fleqn]{amsmath}
\usepackage{amsfonts}
\usepackage{fullpage}
\usepackage{enumerate}
\usepackage{graphicx}             % import, scale, and rotate graphics
\usepackage{subfigure}            % group figures
\usepackage{alltt}
\usepackage{url}
\usepackage{indentfirst}
\usepackage{eurosym}
\usepackage{listings}
\usepackage{color}
\usepackage[table,xcdraw,dvipsnames]{xcolor}

% Change le nom par défaut des listing
\renewcommand{\lstlistingname}{Extrait de Code}

% Change la police des titres pour convenir à votre seul lecteur
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape}
% Idem pour la table des matière.
\usepackage[nottoc,notlof,notlot]{tocbibind}
\usepackage[titles,subfigure]{tocloft}
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape}

\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\newcommand{\coms}[1]{\textcolor{MidnightBlue}{#1}}

\lstset{
    language=C, % Utilisation du langage C
    commentstyle={\color{MidnightBlue}}, % Couleur des commentaires
    frame=single, % Entoure le code d'un joli cadre
    rulecolor=\color{black}, % Couleur de la ligne qui forme le cadre
    stringstyle=\color{RawSienna}, % Couleur des chaines de caractères
    numbers=left, % Ajoute une numérotation des lignes à gauche
    numbersep=5pt, % Distance entre les numérots de lignes et le code
    numberstyle=\tiny\color{mygray}, % Couleur des numéros de lignes
    basicstyle=\tt\footnotesize,
    tabsize=3, % Largeur des tabulations par défaut
    keywordstyle=\tt\bf\footnotesize\color{Sepia}, % Style des mots-clés
    extendedchars=true,
    captionpos=b, % sets the caption-position to bottom
    texcl=true, % Commentaires sur une ligne interprétés en Latex
    showstringspaces=false, % Ne montre pas les espace dans les chaines de caractères
    escapeinside={(>}{<)}, % Permet de mettre du latex entre des <( et )>.
    inputencoding=utf8,
    literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\`E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
}
\newcommand{\tablemat}{~}

%%%%%%%%%%%%%%%%% TITRE %%%%%%%%%%%%%%%%
% Complétez et décommentez les définitions de macros suivantes :
\newcommand{\intitule}{Compléments de Programmation

Récursivité et Élimination de la Récursivité}
\newcommand{\Prenom}{Luca}
\newcommand{\Nom}{Matagne}
\newcommand{\matricule}{s190632}
% Décommentez ceci si vous voulez une table des matières :
\renewcommand{\tablemat}{\tableofcontents}

%%%%%%%% ZONE PROTÉGÉE : MODIFIEZ UNE DES DIX PROCHAINES %%%%%%%%
%%%%%%%%            LIGNES POUR PERDRE 2 PTS.            %%%%%%%%
\title{INFO0947: \intitule}
\author{\textsc{\Prenom}~\textsc{\Nom}, \matricule}
\date{}

\begin{document}
\maketitle
\newpage
\tablemat
\newpage
%%%%%%%%%%%%%%%%%%%% FIN DE LA ZONE PROTÉGÉE %%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%% RAPPORT %%%%%%%%%%%%%%%
% Complétez les sections ci-dessous

\section{Formulation Récursive}\label{formulation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Définition récursive}
Nous observons que :

\begin{lstlisting}

Un nombre décimal est un nombre hexadécimal ayant subi une transformation et 
qu un nombre hexadécimal est un caractère représentant une puissance de 16
ajouté à la suite d une chaine de caractère représentant les puissance de 16
supérieures

\end{lstlisting}

Nous avons donc défini la structure « chaine de caractères(représentant un nombre
hexadécimal) »  récursivement. Nous allons donc formuler la transformation d’une
chaine de caractères en noombre décimaux sur base de cette définition récursive.

Appelons notre notation \textit{Traitement(s,n)}, avec \textit{s} une chaine de
caractères et \textit{n} sa longueur et appelons \textit{Transfo(s[n])} la 
transformation (permettant de passer de hexadécimal à décimal) de l'élément de 
rang n dans la chaine de caractères s.

\subsection{Cas de base}

Une chaine de caractères composée d'un seul caractère est une chaine de caractère
représentant la puissance 0 de 16 en nombre hexadécimal.
Lorsq'uon lui applique la transformation en nombre décimal, on obtient le résultat suivant: 

\centerline{\includegraphics[height=8cm, width=3cm]{AA.png}}

Exemple:

\begin{center}
s={'A,/0'}

\textit{\textbf{Traitement(s,1)=Transfo(s[0])=11}}
\end{center}

\subsection{Cas récursif}

Pour déterminer le cas récursif, observons un exemple:

\begin{center}
\textbf{'A23' $\rightarrow$ 2595}
\end{center}

Imaginons que l$'$on découpe la chaine \textbf{'A23'} selon la définition 
récursive, on a

\begin{center}
\textbf{'A2 || 3' $\rightarrow$ 'A2' + 3 $*$ 1}    

$=$

\textbf{'A2 || 3' $\rightarrow$ 'A2' + 3}

(Le 3 après le $+$ est bien le nombre décimal et plus le caractère)
\end{center}

Et puis,

\begin{center}
\textbf{'A || 23' $\rightarrow$ 'A' + 2$*$16 + 3$*$1}

$=$

\textbf{'A || 23' $\rightarrow$ 'A' + 35}
\end{center}

On voit qu'il faut transformer le dernier caractère de la chaine et additioner le 
résultat de cette transformation au produit du facteur 16 (expliquation
dans le paragraphe suivant) avec le futur résultat du traitement de la chaine de 
caractères examptée du caractère déjà transformé.

La transformation citée depuis le début de ce rapport ne contient pas les
puissances de 16 permettant de passer effectivement d'un nombre hexadécimal à un
nombre décimal. En effet, cette transformation ne faisait qu'allusion à la
fonction \textit{convert(char hex)} préenregistrée pour nous. C'est pourquoi il 
est nécessaire de multiplier l'appel récursif par 16. 

De cette façon, les puissances seront toujours respectées étant donné que pour
atteindre le rang 2 (où nous avons donc 16\up{2}) il y a 2 appels récursifs
(et 1 appel de base). Nous aurons donc un facteur 16*16 au final pour ce rang, ce qui est correct.

I

\begin{center}
\textit{\textbf{Traitement(s, n) = Transfo(s[n-1]) + 16 * Traitement(s, n-1)}}
\end{center}


\subsection{Synthèse}


La formalisation récursive de \textit{Traitement} est donc:

\begin{center}

{\large si n = 0}

\textit{\textbf{Traitement(s, n) =}} 

\textit{\textbf{Transfo(s[0])}} 

\textit{\textbf{{\large ET}}} 

{\large sinon}

\textit{\textbf{Traitement(s, n) =}} 

\textit{\textbf{Traitement(s, n) = Transfo(s[n-1]) + 16 * Traitement(s, n-1)}} 

\end{center}


\section{Spécification}\label{specification}


Etant donné l'utilisation du Pseudo Langage vu au cours, il n'est pas nécessaire 
de vérifier que le pointeur représentant la chaine de caractères est valide
cependant nous allons vérifier que notre chaine existe grâce à sa longueur.

Notons que dans cette section nous reprendrons les notations introduite au début 
de ce rapport.

\begin{center}
{\large PréCondition} $\equiv n > 0$
\end{center}

L'objectif de notre fonction est de tranformer un nombre hexadécimale (sous forme 
de chaine de caractères) en un nombre décimale. En accord avec le code fourni, 
appelons la $hexa\_dec\_rec$. Elle prendra comme argument la chaine de caractère
donnée et sa longueur sous forme d$'$un entier.

\begin{center}
{\large Postondition} $\equiv hexa\_dec\_rec = Traitement(s,n)$
\end{center}

Au final l'interface de la fonnction est:

\begin{lstlisting}
/* 
 * @pre: n > 0
 * @post: hexa_dec_rec = Traitement(s,n)
 */
hexa_dec_rec(s,n)=(int x)
\end{lstlisting}


\section{Construction Récursive}\label{recur}

La structure générale d’une fonction/procédure récursive s’appuie sur une 
structure conditionnelle. On va donc remplir cette structure en trois étapes : 
(i) programmation défensive, (ii) cas de base, (iii) cas récursif(s).

\subsection{Programmation défensive}


En accord avec les préconditions, nous devons nous assurer que la chaine est
utilisable et donc que sa longueur n'est pas nulle. 

\begin{lstlisting}
hexa_dec_rec(s,n):
    if( n<=0 )
    then 
        r<-NULL;
\end{lstlisting}

Dans ce contexte de Pseudo-Langage théorique, je vérifie mes préconditions à 
l$'$aide d$'$une structure conditionnelle. Dans le code cette vérification est traduite par un \textit{assert} comme ceci:

\begin{lstlisting}
unsigned int hexa_dec_rec(char *hexa, int n){
  assert(hexa!=NULL && n>0);
\end{lstlisting}


\subsection{Cas de base}


Si la chaine de caractères n'en contient qu$'$un, on transforme directement ce 
caractère en son équivalent décimal.

\begin{lstlisting}
hexa_dec_rec(s,n):
    // {PréCondition}
    if (n = 1)
    then
        // {int x}
        r<-transfo(s[n-1];
        // {PostCondition}
\end{lstlisting}

\subsection{Cas récursif}


On suit la formulation récursive de \textit{Traitement}.

\begin{lstlisting}
else
    r<-Traitement(s, n) = Transfo(s[n-1]) + 16 * Traitement(s, n-1)
    // {PostCondition}
\end{lstlisting}


\subsection{Code récursif complet}


\begin{lstlisting}
hexa_dec_rec(s,n):
    if (n = 1)
    then
        r<-transfo(s[n-1];
    else
        r<-Traitement(s, n) = Transfo(s[n-1]) + 16 * Traitement(s, n-1)
\end{lstlisting}


\section{Traces d'exécution}\label{traces}


Dans cette section nous allons voire les valeurs qui sont stockées sur la pile
lors de l'exécution de notre fonction. Pour cela nous allons utiliser le même 
exemple que lors de la formalisation récursive de la fonction: $'$A23$'$.
\vspace{0.5cm}

\begin{center}
    

\begin{tabular}{|c|}
\\
\\
3\\
\hline
\textbf{1}
\end{tabular}~~
\begin{tabular}{|c|}
\\
2\\
3\\
\hline
\textbf{2}
\end{tabular}~~
\begin{tabular}{|c|}
10\\
32\\
3\\
\hline
\textbf{3}
\end{tabular}~~
\begin{tabular}{|c|}
2560\\
2\\
3\\
\hline
\textbf{4}
\end{tabular}~~
\begin{tabular}{|c|}
\\
2592\\
3\\
\hline
\textbf{5}
\end{tabular}~~
\begin{tabular}{|c|}
\\
\\
2595\\
\hline
\textbf{6}
\end{tabular}~~

\end{center}

Pour une facilité d'explication, se trouvent en dessous de chaque tableau représentant la pile le numéro lui correspondant.

\subsection{Descente récursive}



\subsection{Tableau 1}
Appel de la fonction. n > 1 donc on entre dans le cas récursif. Le résultat vaut
donc 3 qu'on empile.

\subsubsection{Tableau 2}
2ème appel de la fonction. n > 1 donc on entre dans le cas récursif. Le résultat 
vaut 2. qu'on empile.

\subsubsection{Tableau 3}
3ème appel de la fonction. n == 1donc on entre dans le cas de base. Le résultat 
vaut 10 qu'on empile.

\subsection{Remontée récursive}
Il est temps de faire les calculs.

\subsubsection{Tableau 4}
Etant donné qu'il y avait déjà eu 2 appels de la fonction lorsque le caractère
évalué nous rendait 10 comme résultat, nous devons multiplier ce résultat par 
16\up{2} ce qui donne 2560.

\subsubsection{Tableau 5}
N$'$oublions d$'$additionner à ça (2560) l$'$appel précédent qui rendait 2 comme
résultat mais avant lequel il y avait déjà eu 1 appel de la fonction. Il va donc 
de soi que nous devons multiplier 2 par 16\up{1} = 32 avant de faire l$'$addition.
(Multiplication avant addition car PEMDAS!). Nous avons donc maintenant une somme 
valant 2592.

\subsubsection{Tableau 6}
Cette fois, il nous faut additionner 2592 avec le premier appel de la fonction qui
renvoyait 3 comme résultat. Par définition, il n$'$y avait jamais eu d$'$appel de4
la fonction avant. Il est de ce fait inutile de chercher par quel facteur 3 doit 
être multiplié. Nous pouvons désormais faire notre dernière addition (2592 + 3), 
ce qui nous donne 2595 comme résultat final. 2595$_{10}$ équivaut bien à 
A23$_{16}$.


\section{Complexité}\label{complexite}
%%%%%%%%%%%%%%%%%%%%%
%
% Fournissez et discutez ici la complexité théorique de la fonction
%  hexa_dec_rec()
%

\section{Dérécursification}\label{derecur}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Fournissez et discutez ici la dérécursification de la fonction hexa_dec_rec()
% Attention, il n'est pas question ici de fournir un algorithme itératif mais
% bien d'éliminer la récursivité comme cela a été vu au cours.
% La solution doit être proposée en utilisant le pseudo-code vu au cours (et
% dans les GameCodes du Chapitre 9).
%

\end{document}
